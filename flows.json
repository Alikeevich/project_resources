[
    {
        "id": "eb9e037992d49e66",
        "type": "tab",
        "label": "сборщик данных девайса и отправщик в брокер",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "4f01fce2bb76b4a3",
        "type": "tab",
        "label": "ИСПОЛНИТЕЛЬ КОММАНД",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "8f5ad91c92fb5989",
        "type": "tab",
        "label": "СТАТУС СИСТЕМЫ",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "0b04e47e063c4560",
        "type": "tab",
        "label": "DATA/SHARE",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "536da162b7fcdcc8",
        "type": "tab",
        "label": "загрузчик сценариев",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "b574ae94850ad117",
        "type": "tab",
        "label": "редактор сценариев",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "794ae413063c8cc0",
        "type": "tab",
        "label": "движок сценариев",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "da39ac12fcdfcdcb",
        "type": "tab",
        "label": "ota manager",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "87e4e205cb4297dd",
        "type": "tab",
        "label": "диспетчер тревог",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "77646ae0e4356714",
        "type": "tab",
        "label": "СОПРЯЖЕНИЕ",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "a1b2c3d4.e5f6g7",
        "type": "tab",
        "label": "ГОЛОСОВОЙ АССИСТЕНТ (ФИНАЛ)",
        "disabled": false,
        "info": "Полное управление процессом распознавания ключевых слов с явным перезапуском."
    },
    {
        "id": "93539f02eaf405c3",
        "type": "mqtt-broker",
        "name": "Local broker",
        "broker": "localhost",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "0c06ccdf871dbbbc",
        "type": "mqtt-broker",
        "name": "Cloud broker",
        "broker": "185.129.94.5",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": "60",
        "cleansession": false,
        "autoUnsubscribe": false,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "54590cc59102d80d",
        "type": "function",
        "z": "eb9e037992d49e66",
        "name": "Build cloud topic",
        "func": "// =============================================================================\n// ==      ЦЕНТРАЛЬНЫЙ ОБРАБОТЧИК ДАННЫХ v6.0 (Классификация + Сохранение + Отправка)     ==\n// =============================================================================\n\nconst topic = msg.topic;\nconst devices = global.get(\"devices\") || {};\n\n// --- ЧАСТЬ 1: Игнорируем топики, обрабатываемые другими потоками на этой вкладке ---\nif (topic.endsWith('/availability')) {\n    return null;\n}\n\n// --- ЧАСТЬ 2: Обработка полного списка устройств (bridge/devices) ---\nif (topic === \"zigbee2mqtt/bridge/devices\") {\n    let deviceList;\n    try {\n        deviceList = (typeof msg.payload === 'string') ? JSON.parse(msg.payload) : msg.payload;\n    } catch (e) {\n        node.error(\"Classifier: Failed to parse device list JSON\", msg);\n        return null;\n    }\n\n    deviceList.forEach(devInfo => {\n        if (devInfo.type === 'Coordinator' || !devInfo.friendly_name) return;\n        \n        const name = devInfo.friendly_name;\n        if (!devices[name]) { devices[name] = {}; }\n\n        // Запускаем основную логику классификации по \"паспорту\"\n        classifyDevice(devices[name], devInfo, null);\n    });\n\n    node.log(`Device cache initialized/updated with ${Object.keys(devices).length} devices.`);\n    global.set(\"devices\", devices);\n    return null; // Список устройств не нужно отправлять в облако\n}\n\n// --- ЧАСТЬ 3: Обработка состояний конкретного устройства ---\nconst parts = topic.split('/');\nif (parts[0] === 'zigbee2mqtt' && parts.length === 2 && parts[1] !== 'bridge') {\n    const deviceName = parts[1];\n    const payload = (typeof msg.payload === 'string') ? JSON.parse(msg.payload) : msg.payload;\n\n    if (!devices[deviceName]) { devices[deviceName] = {}; }\n\n    // --- КЛЮЧЕВОЙ МОМЕНТ: СОХРАНЯЕМ ПОСЛЕДНЕЕ СОСТОЯНИЕ ---\n    devices[deviceName].last_payload = payload;\n\n    // Уточняем классификацию, используя данные из payload\n    classifyDevice(devices[deviceName], (payload.device || {}), payload);\n    \n    // Сохраняем обновленный кеш\n    global.set(\"devices\", devices);\n\n    // --- ТЕПЕРЬ ФОРМИРУЕМ И ОТПРАВЛЯЕМ СОСТОЯНИЕ В ОБЛАКО ---\n    const deviceInCache = devices[deviceName];\n    const myHubId = global.get(\"HUB_ID\") || \"unknown_hub\";\n\n    const flatPayload = {};\n    for (const key in payload) {\n        if (key !== 'device' && payload.hasOwnProperty(key)) {\n            flatPayload[key] = payload[key];\n        }\n    }\n    \n    msg.topic = `iss_ai/hubs/${myHubId}/devices/${deviceName}/state`;\n    msg.payload = {\n        ...flatPayload,\n        hubId: myHubId,\n        deviceName: deviceName,\n        device_type: deviceInCache.type || 'unknown',\n        controllable: deviceInCache.controllable || false,\n        // Раз пришли данные, устройство точно онлайн\n        availability: true\n    };\n    \n    // Возвращаем готовое сообщение для отправки в облако\n    return msg; \n}\n\n// Игнорируем все остальные топики (например, bridge/log)\nreturn null;\n\n\n// =============================================================================\n// ==            ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ КЛАССИФИКАЦИИ (встроена)             ==\n// =============================================================================\nfunction classifyDevice(deviceObject, devInfo, payload) {\n    const definition = devInfo.definition || {};\n\n    if (devInfo.manufacturer) deviceObject.manufacturer = devInfo.manufacturer;\n    if (definition.model) deviceObject.model = definition.model;\n    if (devInfo.power_source) deviceObject.power_source = devInfo.power_source;\n\n    const exposes = definition.exposes || [];\n    const features = new Set(exposes.map(f => f.property));\n    const featureTypes = new Set(exposes.map(f => f.type));\n    \n    let deviceType = deviceObject.type || 'generic';\n\n    if (featureTypes.has('light') && features.has('color_xy')) {\n        deviceType = 'light_color';\n    } else if (featureTypes.has('light') && features.has('brightness')) {\n        deviceType = 'light_dimmable';\n    } else if (featureTypes.has('light')) {\n        deviceType = 'light_on_off';\n    } else if (featureTypes.has('switch')) {\n        deviceType = 'switch';\n    } else if (features.has('contact')) {\n        deviceType = 'sensor_contact';\n    } else if (features.has('occupancy')) {\n        deviceType = 'sensor_motion';\n    } else if (features.has('water_leak')) {\n        deviceType = 'sensor_leak';\n    } else if (features.has('smoke')) {\n        deviceType = 'sensor_smoke';\n    } else if (features.has('action')) {\n        if (deviceObject.power_source === 'Mains (single phase)') {\n            deviceType = 'wall_switch';\n        } else {\n            deviceType = 'button';\n        }\n    } else if (features.has('state')) {\n        deviceType = 'switch';\n    } else if (features.has('temperature') || features.has('humidity') || features.has('illuminance')) {\n        deviceType = 'sensor_environment';\n    }\n    \n    if (payload) {\n        if (payload.switch_type === 'toggle') {\n            deviceType = 'switch_toggle';\n        } else if (payload.switch_type === 'momentary') {\n            deviceType = 'switch_button';\n        }\n    }\n    \n    deviceObject.type = deviceType;\n\n    let isControllable = false;\n    if (exposes.length > 0) {\n        for (const feature of exposes) {\n            if (feature.access && (feature.access & 2)) {\n                isControllable = true;\n                break;\n            }\n        }\n        deviceObject.controllable = isControllable;\n    }\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 180,
        "wires": [
            [
                "4ac190146191215e"
            ]
        ]
    },
    {
        "id": "4ac190146191215e",
        "type": "mqtt out",
        "z": "eb9e037992d49e66",
        "name": "",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "0c06ccdf871dbbbc",
        "x": 950,
        "y": 260,
        "wires": []
    },
    {
        "id": "a9be9dc999c68ab1",
        "type": "debug",
        "z": "eb9e037992d49e66",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 580,
        "y": 300,
        "wires": []
    },
    {
        "id": "749ea7811a58da1f",
        "type": "mqtt in",
        "z": "eb9e037992d49e66",
        "name": "listen to z2m states local",
        "topic": "zigbee2mqtt/#",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "93539f02eaf405c3",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 370,
        "y": 180,
        "wires": [
            [
                "54590cc59102d80d",
                "a9be9dc999c68ab1"
            ]
        ]
    },
    {
        "id": "e473a1360db9f9af",
        "type": "mqtt in",
        "z": "eb9e037992d49e66",
        "name": "listen to z2m availability",
        "topic": "zigbee2mqtt/+/availability",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "93539f02eaf405c3",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 400,
        "y": 420,
        "wires": [
            [
                "8782b683543a41b2"
            ]
        ]
    },
    {
        "id": "8782b683543a41b2",
        "type": "function",
        "z": "eb9e037992d49e66",
        "name": "function 6",
        "func": "// =============================================================================\n// ==     НАДЕЖНЫЙ ОБРАБОТЧИК ДОСТУПНОСТИ v2.0 (Кеш + Немедленная отправка)   ==\n// =============================================================================\n\nconst deviceName = msg.topic.split('/')[1];\nif (deviceName === 'bridge') return null;\n\nconst isOnline = (msg.payload === 'online');\n\n// --- 1. Обновляем кеш ---\nconst devices = global.get(\"devices\") || {};\nif (!devices[deviceName]) { devices[deviceName] = {}; }\ndevices[deviceName].availability = isOnline;\nglobal.set(\"devices\", devices);\n\n// --- 2. Готовим и отправляем полное состояние в облако НЕМЕДЛЕННО ---\nconst myHubId = global.get(\"HUB_ID\") || \"unknown_hub\";\nconst deviceInCache = devices[deviceName];\n\n// Берем последнее известное состояние или пустой объект\nconst lastPayload = deviceInCache.last_payload || {};\n\n// \"Выравниваем\" JSON\nconst flatPayload = {};\nfor (const key in lastPayload) {\n    if (key !== 'device') { flatPayload[key] = lastPayload[key]; }\n}\n\n// Формируем топик для облака\nmsg.topic = `iss_ai/hubs/${myHubId}/devices/${deviceName}/state`;\n\n// Формируем финальный payload, добавляя ВСЕ данные из кеша\nmsg.payload = {\n    ...flatPayload,\n    // САМОЕ ГЛАВНОЕ: добавляем актуальный статус доступности\n    availability: isOnline,\n    \n    hubId: myHubId,\n    deviceName: deviceName,\n    device_type: deviceInCache.type || 'unknown',\n    controllable: deviceInCache.controllable || false\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 420,
        "wires": [
            [
                "703413a4258b15c9"
            ]
        ]
    },
    {
        "id": "703413a4258b15c9",
        "type": "mqtt out",
        "z": "eb9e037992d49e66",
        "name": "",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "0c06ccdf871dbbbc",
        "x": 610,
        "y": 520,
        "wires": []
    },
    {
        "id": "cloud_command_in",
        "type": "mqtt in",
        "z": "4f01fce2bb76b4a3",
        "name": "Cloud → Command",
        "topic": "iss_ai/hubs/+/devices/+/command",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "0c06ccdf871dbbbc",
        "nl": false,
        "rap": false,
        "inputs": 0,
        "x": 430,
        "y": 240,
        "wires": [
            [
                "build_z2m_command"
            ]
        ]
    },
    {
        "id": "build_z2m_command",
        "type": "function",
        "z": "4f01fce2bb76b4a3",
        "name": "Build Z2M command",
        "func": "// Node-RED Function: Build Z2M command\nconst myHubId = global.get(\"HUB_ID\");\nconst topicParts = msg.topic.split('/');\nconst targetHubId = topicParts[2];\nconst deviceName = topicParts[4];\n\n// Игнорируем команды не для нашего хаба\nif (myHubId !== targetHubId) {\n    return null;\n}\n\n// Сохраняем correlationId в flow-контексте\nconst correlationId = msg.payload.correlationId;\nflow.set(`corr_${deviceName}`, correlationId);\n\n// Формируем топик для отправки в zigbee2mqtt\nmsg.topic = `zigbee2mqtt/${deviceName}/set`;\n\n// Клонируем и дополняем payload\nmsg.payload = {\n    ...msg.payload.payload,\n    correlationId: correlationId\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 240,
        "wires": [
            [
                "mqtt_to_z2m"
            ]
        ]
    },
    {
        "id": "mqtt_to_z2m",
        "type": "mqtt out",
        "z": "4f01fce2bb76b4a3",
        "name": "Z2M ← Command",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "93539f02eaf405c3",
        "x": 980,
        "y": 240,
        "wires": []
    },
    {
        "id": "z2m_device_state",
        "type": "mqtt in",
        "z": "4f01fce2bb76b4a3",
        "name": "Z2M → State",
        "topic": "zigbee2mqtt/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "93539f02eaf405c3",
        "nl": false,
        "rap": false,
        "inputs": 0,
        "x": 430,
        "y": 400,
        "wires": [
            [
                "build_state_response"
            ]
        ]
    },
    {
        "id": "build_state_response",
        "type": "function",
        "z": "4f01fce2bb76b4a3",
        "name": "Build Cloud Response",
        "func": "// =============================================================================\n// ==           ТРАНСЛЯТОР СОСТОЯНИЙ v5.0 (Production Ready)                  ==\n// == Задача: Слушать сообщения от устройств, ВЫРАВНИВАТЬ JSON,             ==\n// == ОБОГАЩАТЬ данными из кеша и отправлять в облако.                     ==\n// =============================================================================\n\nconst topicParts = msg.topic.split('/');\nconst deviceName = topicParts[1];\n\nif (deviceName === 'bridge') {\n    return null;\n}\n\n// --- 1. Загружаем все необходимые данные ---\nconst myHubId = global.get(\"HUB_ID\") || \"unknown_hub\";\nconst devices = global.get(\"devices\") || {};\nconst deviceInCache = devices[deviceName];\n\nif (!deviceInCache) {\n    node.warn(`Received state from '${deviceName}' but it's not in cache yet. Ignoring.`);\n    return null;\n}\n\n// --- 2. \"Выравниваем\" JSON ---\nconst flatPayload = {};\nconst rawPayload = (typeof msg.payload === 'string') ? JSON.parse(msg.payload) : msg.payload;\n\nfor (const key in rawPayload) {\n    if (key !== 'device' && rawPayload.hasOwnProperty(key)) {\n        flatPayload[key] = rawPayload[key];\n    }\n}\nif (rawPayload.device) {\n    if (rawPayload.device.manufacturerName) {\n        flatPayload.manufacturer = rawPayload.device.manufacturerName;\n    }\n    if (rawPayload.device.modelID) {\n        flatPayload.model = rawPayload.device.modelID;\n    }\n}\n\n// --- 3. Формируем ОБЯЗАТЕЛЬНОЕ сообщение о состоянии ---\nconst stateMsg = {\n    topic: `iss_ai/hubs/${myHubId}/devices/${deviceName}/state`,\n    payload: {\n        ...flatPayload,\n        hubId: myHubId,\n        deviceName: deviceName,\n        // --- ДОБАВЛЯЕМ ОБОГАЩЕННЫЕ ДАННЫЕ ИЗ КЕША ---\n        device_type: deviceInCache.type || 'unknown',\n        controllable: deviceInCache.controllable || false\n    }\n};\n\n// --- 4. Формируем ОПЦИОНАЛЬНОЕ сообщение об анонсе ---\nlet announceMsg = null;\nif (!deviceInCache.announced && deviceInCache.manufacturer && deviceInCache.model) {\n    announceMsg = {\n        topic: `iss_ai/hubs/${myHubId}/device_announce`,\n        payload: {\n            hubId: myHubId,\n            new_device_joined: deviceName,\n            manufacturer: deviceInCache.manufacturer,\n            model: deviceInCache.model,\n            device_type: deviceInCache.type || 'unknown',\n            controllable: deviceInCache.controllable || false,\n            parameters: flatPayload\n        }\n    };\n    \n    deviceInCache.announced = true;\n    global.set(\"devices\", devices);\n}\n\nreturn [stateMsg, announceMsg];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 760,
        "y": 400,
        "wires": [
            [
                "mqtt_to_cloud_state"
            ],
            [
                "074a8697d3e1be04"
            ]
        ]
    },
    {
        "id": "mqtt_to_cloud_state",
        "type": "mqtt out",
        "z": "4f01fce2bb76b4a3",
        "name": "Cloud ← State",
        "topic": "",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "0c06ccdf871dbbbc",
        "x": 1000,
        "y": 340,
        "wires": []
    },
    {
        "id": "074a8697d3e1be04",
        "type": "mqtt out",
        "z": "4f01fce2bb76b4a3",
        "name": "",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "0c06ccdf871dbbbc",
        "x": 970,
        "y": 460,
        "wires": []
    },
    {
        "id": "c19e4a2d44f69634",
        "type": "inject",
        "z": "8f5ad91c92fb5989",
        "name": "every 1 minute",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "60",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 200,
        "y": 200,
        "wires": [
            [
                "805d0a06912572d9"
            ]
        ]
    },
    {
        "id": "805d0a06912572d9",
        "type": "function",
        "z": "8f5ad91c92fb5989",
        "name": "build system status",
        "func": "// Получаем доступ к разрешенным системным модулям\nconst fs = global.get('fs');\nconst os = global.get('os');\nconst execSync = global.get('child_process').execSync;\n\n// --- 1. Получаем HUB_ID и FW_VERSION ---\nlet hub_id = context.get('hub_id');\nlet fw_version = context.get('fw_version');\n\nif (!hub_id) {\n    try {\n        hub_id = fs.readFileSync('/etc/iss_ai_hub/hub_id.txt', 'utf8').trim();\n        context.set('hub_id', hub_id);\n    } catch (e) {\n        // ИСПРАВЛЕНО: Объединяем все в одну строку\n        node.error(`FATAL: Could not read hub_id.txt. Error: ${e.message}`);\n        return null;\n    }\n}\n\nif (!fw_version) {\n    try {\n        fw_version = fs.readFileSync('/etc/iss_ai_hub/version.txt', 'utf8').trim();\n        context.set('fw_version', fw_version);\n    } catch (e) {\n        // ИСПРАВЛЕНО: Объединяем все в одну строку\n        node.warn(`Could not read version.txt, using default. Error: ${e.message}`);\n        fw_version = \"unknown\";\n    }\n}\n\n// --- 2. Получаем Uptime ---\nlet uptime_str = \"unknown\";\ntry {\n    const uptime_seconds = os.uptime();\n    const days = Math.floor(uptime_seconds / 86400);\n    const hours = Math.floor((uptime_seconds % 86400) / 3600);\n    const minutes = Math.floor((uptime_seconds % 3600) / 60);\n    uptime_str = `up ${days}d, ${hours}h, ${minutes}m`;\n} catch (e) { /* Игнорируем */ }\n\n\n// --- 3. Получаем IP-адрес ---\nlet wifi_ip = \"N/A\";\ntry {\n    const output = execSync(\"ip -4 addr show wlan0 | grep -oP '(?<=inet\\\\s)\\\\d+(\\\\.\\\\d+){3}'\").toString().trim();\n    if (output) { wifi_ip = output; }\n} catch (e) { /* Игнорируем */ }\n\n// --- 4. Формируем финальный объект и топик ---\nmsg.payload = {\n    hub_id: hub_id,\n    fw_version: fw_version,\n    uptime: uptime_str,\n    wifi_ip: wifi_ip\n};\nmsg.topic = `iss_ai/hubs/${hub_id}/system_status`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 200,
        "wires": [
            [
                "39b3a4a45ca31dfb"
            ]
        ]
    },
    {
        "id": "39b3a4a45ca31dfb",
        "type": "mqtt out",
        "z": "8f5ad91c92fb5989",
        "name": "Publish system status",
        "topic": "",
        "qos": "",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "0c06ccdf871dbbbc",
        "x": 640,
        "y": 200,
        "wires": []
    },
    {
        "id": "20985a97ab9475a5",
        "type": "mqtt in",
        "z": "0b04e47e063c4560",
        "name": "listen to the SHARE",
        "topic": "iss_ai/hubs/+/devices/data/share",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "0c06ccdf871dbbbc",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 190,
        "y": 100,
        "wires": [
            [
                "85ce38ef825a22f0",
                "2f7b7e31ffb4b144"
            ]
        ]
    },
    {
        "id": "85ce38ef825a22f0",
        "type": "function",
        "z": "0b04e47e063c4560",
        "name": "function 1",
        "func": "// =============================================================================\n// ==           DATA/SHARE v4.2 (Исправленная версия с Availability)          ==\n// =============================================================================\n\n// --- 1. Фильтрация и подготовка ---\nconst myHubId = global.get(\"HUB_ID\");\nconst topicParts = msg.topic.split('/');\nconst targetHubId = topicParts[2];\n\nif (!myHubId || myHubId !== targetHubId) {\n    return null;\n}\n\nconst devices = global.get(\"devices\") || {};\nconst commandPayload = msg.payload;\nconst correlationId = commandPayload.correlationId || null;\n\n// --- 2. Универсальная функция форматирования (ОБНОВЛЕНА!) ---\nfunction formatDevicePayload(deviceName, deviceInCache) {\n    // Условие выхода: нет самого устройства или нет его последнего состояния\n    if (!deviceInCache || !deviceInCache.last_payload) {\n        return null;\n    }\n\n    // --- Шаг 2.1: \"Выравниваем\" JSON ---\n    const flatPayload = {};\n    const rawPayload = deviceInCache.last_payload;\n\n    for (const key in rawPayload) {\n        if (key !== 'device' && rawPayload.hasOwnProperty(key)) {\n            flatPayload[key] = rawPayload[key];\n        }\n    }\n    if (rawPayload.device) {\n        if (rawPayload.device.manufacturerName) {\n            flatPayload.manufacturer = rawPayload.device.manufacturerName;\n        }\n        if (rawPayload.device.modelID) {\n            flatPayload.model = rawPayload.device.modelID;\n        }\n    }\n\n    // --- Шаг 2.2: Формируем финальный \"обогащенный\" payload ---\n    return {\n        ...flatPayload,\n        deviceId: deviceName,\n        manufacturer: deviceInCache.manufacturer || flatPayload.manufacturer,\n        model: deviceInCache.model || flatPayload.model,\n        hubId: myHubId,\n        correlationId: correlationId,\n        device_type: deviceInCache.type || 'unknown',\n        controllable: deviceInCache.controllable || false,\n        // --- ГЛАВНОЕ ИЗМЕНЕНИЕ: Включаем статус доступности из кеша ---\n        availability: (deviceInCache.availability !== undefined) ? deviceInCache.availability : true\n    };\n}\n\n\n// --- 3. Вспомогательная функция для отправки ответа ---\nfunction sendControlResponse(success, message) {\n    if (correlationId) {\n        // Отправляем сообщение в ПЕРВЫЙ выход узла\n        node.send([{\n            topic: `iss_ai/hubs/${myHubId}/devices/data/response`,\n            payload: {\n                correlationId: correlationId,\n                hubId: myHubId,\n                success: success,\n                message: message\n            }\n        }, null]);\n    }\n}\n\n// --- 4. Логика для режима Streaming Mode ---\nif (commandPayload.stream_target_name) {\n    const targetName = commandPayload.stream_target_name;\n    const duration = (commandPayload.stream_duration_sec || 60) * 1000;\n    const interval = (commandPayload.stream_interval_sec || 5) * 1000;\n\n    const device = devices[targetName];\n    if (device && device.last_payload) {\n        sendControlResponse(true, `Streaming started for ${targetName}`);\n        let count = 0;\n        const limit = Math.floor(duration / interval);\n\n        const timer = setInterval(() => {\n            const currentDeviceInCache = (global.get(\"devices\") || {})[targetName];\n            if (!currentDeviceInCache || !currentDeviceInCache.last_payload || count >= limit) {\n                clearInterval(timer);\n                return;\n            }\n\n            const formattedPayload = formatDevicePayload(targetName, currentDeviceInCache);\n            if (formattedPayload) {\n                // Отправляем данные во ВТОРОЙ выход узла\n                node.send([null, {\n                    topic: `iss_ai/hubs/${myHubId}/devices/${targetName}/state`,\n                    payload: formattedPayload\n                }]);\n            }\n            count++;\n        }, interval);\n\n    } else {\n        sendControlResponse(false, `Device ${targetName} not found or no data`);\n    }\n    // В асинхронном режиме (с setInterval) основной поток нужно остановить\n    return null;\n}\n\n\n// --- 5. Логика для One-time data share ---\nsendControlResponse(true, \"One-time data sync started\");\n\nfor (const deviceName in devices) {\n    const deviceInCache = devices[deviceName];\n    const formattedPayload = formatDevicePayload(deviceName, deviceInCache);\n\n    if (formattedPayload) {\n        // Отправляем данные во ВТОРОЙ выход узла\n        node.send([null, {\n            topic: `iss_ai/hubs/${myHubId}/devices/${deviceName}/state`,\n            payload: formattedPayload\n        }]);\n    }\n}\n\n// Мы сами управляли отправкой через node.send, поэтому основной поток останавливаем\nreturn null;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 160,
        "y": 180,
        "wires": [
            [
                "df08750f6afed4d9"
            ],
            [
                "986f14ca61f25869"
            ]
        ]
    },
    {
        "id": "df08750f6afed4d9",
        "type": "mqtt out",
        "z": "0b04e47e063c4560",
        "name": "",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "0c06ccdf871dbbbc",
        "x": 350,
        "y": 160,
        "wires": []
    },
    {
        "id": "986f14ca61f25869",
        "type": "mqtt out",
        "z": "0b04e47e063c4560",
        "name": "",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "0c06ccdf871dbbbc",
        "x": 350,
        "y": 220,
        "wires": []
    },
    {
        "id": "2f7b7e31ffb4b144",
        "type": "debug",
        "z": "0b04e47e063c4560",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 440,
        "y": 100,
        "wires": []
    },
    {
        "id": "0f8081be32445f14",
        "type": "inject",
        "z": "536da162b7fcdcc8",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "3",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 120,
        "y": 80,
        "wires": [
            [
                "f4b4bd7cc3742ad3"
            ]
        ]
    },
    {
        "id": "f4b4bd7cc3742ad3",
        "type": "exec",
        "z": "536da162b7fcdcc8",
        "command": "cat /home/berkut/scenarios.json",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 230,
        "y": 160,
        "wires": [
            [
                "df73a3613e3bfe3d"
            ],
            [],
            []
        ]
    },
    {
        "id": "df73a3613e3bfe3d",
        "type": "function",
        "z": "536da162b7fcdcc8",
        "name": "сохранить сценарии в глобал",
        "func": "try {\n    // Преобразуем строку из файла в объект JSON\n    const scenarios = JSON.parse(msg.payload);\n    // Сохраняем в глобальную переменную\n    global.set(\"scenarios\", scenarios);\n    node.log(`Successfully loaded ${scenarios.length} scenarios.`);\n} catch (e) {\n    node.error(\"Failed to parse scenarios.json! \" + e.message);\n    // Если файл пустой или некорректный, создаем пустой массив\n    global.set(\"scenarios\", []);\n}\nreturn null; // Ничего не отправляем дальше",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "65329fdd1e2a925d",
        "type": "mqtt in",
        "z": "b574ae94850ad117",
        "name": "",
        "topic": "iss_ai/hubs/+/scenarios/#",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "0c06ccdf871dbbbc",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 150,
        "y": 120,
        "wires": [
            [
                "4be71902116c209e"
            ]
        ]
    },
    {
        "id": "4be71902116c209e",
        "type": "function",
        "z": "b574ae94850ad117",
        "name": "function 2",
        "func": "// Проверяем, что команда для нашего хаба\nconst myHubId = global.get(\"HUB_ID\");\nconst targetHubId = msg.topic.split('/')[2];\nif (myHubId !== targetHubId) { return null; }\n\nlet scenarios = global.get(\"scenarios\") || [];\nconst command = msg.topic.split('/')[4]; // 'set' или 'delete'\nconst scenarioName = msg.payload.name;\n\nif (!scenarioName) {\n    node.error(\"Received scenario command without a name.\");\n    return null;\n}\n\n// Удаляем существующий сценарий с таким же именем\nscenarios = scenarios.filter(s => s.name !== scenarioName);\n\n// Если команда 'set', добавляем новый/обновленный сценарий\nif (command === 'set') {\n    scenarios.push(msg.payload); // msg.payload - это уже готовый объект сценария\n    node.log(`Scenario '${scenarioName}' added/updated.`);\n} else if (command === 'delete') {\n    node.log(`Scenario '${scenarioName}' deleted.`);\n}\n\n// Обновляем глобальную переменную и передаем дальше для сохранения в файл\nglobal.set(\"scenarios\", scenarios);\nmsg.payload = scenarios; // Передаем полный массив сценариев\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 120,
        "wires": [
            [
                "bd051fd4bceee4cc"
            ]
        ]
    },
    {
        "id": "bd051fd4bceee4cc",
        "type": "exec",
        "z": "b574ae94850ad117",
        "command": "tee /home/berkut/scenarios.json",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "scenarios.json на диск",
        "x": 640,
        "y": 120,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "18c072f280eb4c24",
        "type": "mqtt in",
        "z": "794ae413063c8cc0",
        "name": "",
        "topic": "zigbee2mqtt/+",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "93539f02eaf405c3",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 110,
        "y": 60,
        "wires": [
            [
                "889a52ad4e2db427"
            ]
        ]
    },
    {
        "id": "889a52ad4e2db427",
        "type": "function",
        "z": "794ae413063c8cc0",
        "name": "function 3",
        "func": "// =============================================================================\n//  Продвинутый Движок Сценариев для Node-RED v1.0\n//  Аналог логики хаба ISS AI Hub v2.3\n// =============================================================================\n\n// --- Вспомогательная функция для проверки условий и триггеров ---\n// Она является сердцем нового движка.\nfunction checkCondition(condition, allDevices) {\n    // --- Часть 1: Проверка внутренних условий (время) ---\n    if (condition.deviceName === \"_internal_\") {\n        if (condition.attribute === \"time\") {\n            try {\n                const now = new Date();\n                const currentHour = now.getHours();\n\n                // Парсим время из строки \"HH:MM-HH:MM\"\n                const startHour = parseInt(condition.value.substring(0, 2), 10);\n                const endHour = parseInt(condition.value.substring(6, 8), 10);\n\n                // Проверка на корректность формата\n                if (isNaN(startHour) || isNaN(endHour)) {\n                    node.error(`Неверный формат времени в сценарии: ${condition.value}`);\n                    return false;\n                }\n\n                // Правильная проверка интервала, переходящего через полночь\n                if (startHour > endHour) {\n                    return (currentHour >= startHour || currentHour < endHour);\n                } else {\n                    return (currentHour >= startHour && currentHour < endHour);\n                }\n            } catch (e) {\n                node.error(`Ошибка при проверке времени: ${e.message}`);\n                return false;\n            }\n        }\n        return false; // Неизвестный внутренний атрибут\n    }\n\n    // --- Часть 2: Проверка условий по физическим устройствам ---\n    const device = allDevices[condition.deviceName];\n\n    // Убеждаемся, что устройство существует в базе и у него есть данные\n    if (!device || !device.last_payload) {\n        // Не выводим ошибку, т.к. устройство может быть временно оффлайн\n        return false;\n    }\n\n    // Получаем текущее значение атрибута у устройства\n    const deviceValue = device.last_payload[condition.attribute];\n\n    // Если у устройства нет такого атрибута, условие ложно\n    if (deviceValue === undefined) {\n        return false;\n    }\n\n    // Получаем значение из условия\n    const conditionValue = condition.value;\n\n    // --- Часть 3: Сравнение с учетом оператора и типов данных ---\n    const numDeviceValue = parseFloat(deviceValue);\n    const numConditionValue = parseFloat(conditionValue);\n\n    switch (condition.op) {\n        case \"==\":\n            // Для булевых значений (true/false) сравниваем их правильно\n            if (typeof deviceValue === 'boolean') {\n                return deviceValue === (conditionValue === 'true');\n            }\n            // Для всего остального используем нестрогое сравнение,\n            // чтобы \"100\" было равно 100\n            return deviceValue == conditionValue;\n\n        case \"!=\":\n            if (typeof deviceValue === 'boolean') {\n                return deviceValue !== (conditionValue === 'true');\n            }\n            return deviceValue != conditionValue;\n\n        case \">\":\n            return numDeviceValue > numConditionValue;\n\n        case \"<\":\n            return numDeviceValue < numConditionValue;\n\n        default:\n            node.warn(`Неизвестный оператор в сценарии: ${condition.op}`);\n            return false;\n    }\n}\n\n\n// =============================================================================\n//  Основная логика обработки входящего сообщения\n// =============================================================================\n\n// Получаем данные из входящего MQTT-сообщения\n// msg.topic = \"zigbee2mqtt/corridor_motion_sensor\"\n// msg.payload = {\"contact\": false, \"battery\": 98, ...}\nconst updatedDeviceName = msg.topic.split('/')[1];\nconst updatedPayload = msg.payload;\n\n// Если сообщение не является состоянием устройства, игнорируем его\nif (!updatedDeviceName || typeof updatedPayload !== 'object') {\n    return null;\n}\n\n// Загружаем сценарии и состояния устройств из глобального контекста\nconst scenarios = global.get(\"scenarios\") || [];\nconst allDevices = global.get(\"devices\") || {};\n\n// Создаем \"виртуальную базу данных\" для текущего события, чтобы использовать\n// ту же функцию checkCondition для проверки триггера.\nconst currentStateForTrigger = {\n    [updatedDeviceName]: {\n        last_payload: updatedPayload\n    }\n};\n\n// Проходим по каждому сценарию\nfor (const scenario of scenarios) {\n    if (!scenario.enabled) continue;\n\n    let triggerFired = false;\n    // Проверяем, подходит ли наше событие под один из триггеров\n    for (const trigger of scenario.triggers) {\n        // Проверяем, что триггер для нашего устройства и тип триггера \"device\"\n        if (trigger.deviceName === updatedDeviceName && trigger.type === \"device\") {\n            // Используем нашу новую умную функцию для проверки триггера\n            if (checkCondition(trigger, currentStateForTrigger)) {\n                triggerFired = true;\n                node.log(`Сработал триггер для сценария \"${scenario.name}\" от устройства \"${updatedDeviceName}\"`);\n                break;\n            }\n        }\n    }\n\n    // Если триггер сработал, проверяем дополнительные условия\n    if (triggerFired) {\n        let allConditionsMet = true;\n        for (const condition of scenario.conditions) {\n            // И снова используем нашу умную функцию для проверки условий\n            if (!checkCondition(condition, allDevices)) {\n                allConditionsMet = false;\n                node.log(`  - Условие для \"${scenario.name}\" НЕ выполнено: ${condition.deviceName}.${condition.attribute} ${condition.op} ${condition.value}`);\n                break; // Одно условие не выполнено - вся проверка провалена\n            }\n        }\n\n        // Если все условия выполнены, выполняем действия\n        if (allConditionsMet) {\n            node.warn(`>>> ВЫПОЛНЯЕТСЯ СЦЕНАРИЙ: \"${scenario.name}\"`);\n            for (const action of scenario.actions) {\n                try {\n                    const topic = `zigbee2mqtt/${action.deviceName}/set`;\n                    const payload = JSON.parse(action.commandJson);\n                    \n                    // Отправляем команду в MQTT\n                    node.send({\n                        topic: topic,\n                        payload: payload\n                    });\n                     node.log(`    -> Отправлена команда: топик [${topic}], данные: ${action.commandJson}`);\n                } catch(e) {\n                    node.error(`Ошибка выполнения действия для сценария \"${scenario.name}\": ${e.message}`);\n                }\n            }\n        }\n    }\n}\n\n// Мы сами отправляем сообщения через node.send(), поэтому основной поток останавливаем.\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 300,
        "y": 60,
        "wires": [
            [
                "43ece0467494f063"
            ]
        ]
    },
    {
        "id": "43ece0467494f063",
        "type": "mqtt out",
        "z": "794ae413063c8cc0",
        "name": "",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "93539f02eaf405c3",
        "x": 490,
        "y": 60,
        "wires": []
    },
    {
        "id": "c091237e78a7f02f",
        "type": "mqtt in",
        "z": "da39ac12fcdfcdcb",
        "name": "",
        "topic": "iss_ai/hubs/+/ota/command",
        "qos": "2",
        "datatype": "utf8",
        "broker": "0c06ccdf871dbbbc",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 160,
        "y": 240,
        "wires": [
            [
                "4cbac46828d2f57e"
            ]
        ]
    },
    {
        "id": "4cbac46828d2f57e",
        "type": "function",
        "z": "da39ac12fcdfcdcb",
        "name": "Filter & Parse OTA",
        "func": "// Получаем ID нашего хаба из глобальной переменной\nconst myHubId = global.get(\"HUB_ID\");\n// Получаем ID, на который пришла команда, из топика\nconst targetHubId = msg.topic.split('/')[2];\n\n// Проверяем, что команда адресована нам. Если нет - игнорируем.\nif (myHubId !== targetHubId) {\n    return null; // Останавливаем поток\n}\n\n// Пробуем распарсить входящую строку в JSON\nlet payload;\ntry {\n    payload = JSON.parse(msg.payload);\n} catch (e) {\n    node.error(\"Invalid JSON received in OTA command\", msg);\n    return null; // Останавливаем поток, если JSON \"битый\"\n}\n\n// Проверяем, есть ли в команде обязательное поле 'action'\nif (!payload.action) {\n    node.error(\"OTA command is missing 'action' field\", msg);\n    return null; // Останавливаем поток\n}\n\n// Сохраняем оригинальный payload для будущего ответа\nmsg.original_payload = payload;\n// В основной payload кладем только саму команду для удобства\nmsg.payload = payload.action;\n\n// Отправляем сообщение дальше\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 540,
        "wires": [
            [
                "bbf9d556615c4091"
            ]
        ]
    },
    {
        "id": "bbf9d556615c4091",
        "type": "switch",
        "z": "da39ac12fcdfcdcb",
        "name": "route ota action",
        "property": "payload",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "update_core",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "update_z2m",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "update_system",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "reboot",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 540,
        "y": 280,
        "wires": [
            [
                "cc703a8a869bb17c"
            ],
            [
                "4486c8056e40a9d7"
            ],
            [
                "fa33aaeaec89a303"
            ],
            [
                "1cef990be1c1ff38"
            ]
        ]
    },
    {
        "id": "cc703a8a869bb17c",
        "type": "exec",
        "z": "da39ac12fcdfcdcb",
        "command": "sudo /usr/local/bin/update_core.sh",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "300",
        "winHide": false,
        "oldrc": false,
        "name": "core update",
        "x": 690,
        "y": 180,
        "wires": [
            [
                "3aea8c787d7492a9"
            ],
            [
                "3aea8c787d7492a9"
            ],
            [
                "3aea8c787d7492a9"
            ]
        ]
    },
    {
        "id": "4486c8056e40a9d7",
        "type": "exec",
        "z": "da39ac12fcdfcdcb",
        "command": "sudo /usr/local/bin/update_z2m.sh",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "300",
        "winHide": false,
        "oldrc": false,
        "name": "run z2m update",
        "x": 760,
        "y": 240,
        "wires": [
            [
                "3aea8c787d7492a9"
            ],
            [
                "3aea8c787d7492a9"
            ],
            [
                "3aea8c787d7492a9"
            ]
        ]
    },
    {
        "id": "fa33aaeaec89a303",
        "type": "exec",
        "z": "da39ac12fcdfcdcb",
        "command": "sudo /usr/local/bin/update_system.sh",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "900",
        "winHide": false,
        "oldrc": false,
        "name": "run system update",
        "x": 770,
        "y": 320,
        "wires": [
            [
                "3aea8c787d7492a9"
            ],
            [
                "3aea8c787d7492a9"
            ],
            [
                "3aea8c787d7492a9"
            ]
        ]
    },
    {
        "id": "1cef990be1c1ff38",
        "type": "exec",
        "z": "da39ac12fcdfcdcb",
        "command": "sudo /usr/local/bin/reboot.sh",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "30",
        "winHide": false,
        "oldrc": false,
        "name": "run reboot",
        "x": 690,
        "y": 380,
        "wires": [
            [
                "3aea8c787d7492a9"
            ],
            [
                "3aea8c787d7492a9"
            ],
            [
                "3aea8c787d7492a9"
            ]
        ]
    },
    {
        "id": "3aea8c787d7492a9",
        "type": "function",
        "z": "da39ac12fcdfcdcb",
        "name": "format ota response",
        "func": "// msg.rc содержит код возврата от exec. 0 = успех.\nconst success = (msg.rc && msg.rc.code === 0);\n\n// Формируем полезную нагрузку для ответа\nconst response_payload = {\n    status: success ? \"success\" : \"failure\",\n    // Берем action из сохраненного payload\n    action: msg.original_payload.action,\n    // В details кладем вывод скрипта (stdout или stderr)\n    details: msg.payload,\n    code: msg.rc ? msg.rc.code : null,\n    // Добавляем correlationId, если он был в исходном запросе\n    correlationId: msg.original_payload.correlationId || null\n};\n\n// Переделываем msg для отправки в MQTT\nmsg.payload = response_payload;\nmsg.topic = `iss_ai/hubs/${global.get(\"HUB_ID\")}/ota/response`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 280,
        "wires": [
            [
                "544ce6ad94b338b1"
            ]
        ]
    },
    {
        "id": "544ce6ad94b338b1",
        "type": "mqtt out",
        "z": "da39ac12fcdfcdcb",
        "name": "publish ota response",
        "topic": "",
        "qos": "2",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "0c06ccdf871dbbbc",
        "x": 1280,
        "y": 280,
        "wires": []
    },
    {
        "id": "b400ff2dad893981",
        "type": "mqtt in",
        "z": "87e4e205cb4297dd",
        "name": "слушать все",
        "topic": "zigbee2mqtt/+",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "93539f02eaf405c3",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 150,
        "y": 100,
        "wires": [
            [
                "5494846f0b5540c6"
            ]
        ]
    },
    {
        "id": "5494846f0b5540c6",
        "type": "function",
        "z": "87e4e205cb4297dd",
        "name": "function 4",
        "func": "// =================================================================\n// === УНИВЕРСАЛЬНЫЙ ДИСПЕТЧЕР ТРЕВОГ v4 (с уровнями и всеми типами) ===\n// =================================================================\n\nconst deviceName = msg.topic.split('/')[1];\nif (deviceName === 'bridge') {\n    return null;\n}\n\nconst payload = (typeof msg.payload === 'string') ? JSON.parse(msg.payload) : msg.payload;\nif (typeof payload !== 'object' || payload === null) {\n    return null;\n}\n\nlet alarmType = null;    // Тип события (e.g., 'contact', 'motion')\nlet alarmState = null;   // Состояние: true (ТРЕВОГА) / false (НОРМА)\nlet alarmLevel = null;   // Важность: 'high', 'medium', 'low'\nlet isAlarmEvent = false; // Флаг, что это релевантное событие\n\n// -----------------------------------------------------------------\n// --- БИБЛИОТЕКА ОПРЕДЕЛЕНИЯ ТРЕВОГ ---\n// -----------------------------------------------------------------\n\n// --- ВЫСОКИЙ УРОВЕНЬ ВАЖНОСТИ (Critical) ---\n\nif (payload.hasOwnProperty('water_leak')) {\n    isAlarmEvent = true;\n    alarmType = \"water_leak\";\n    alarmState = (payload.water_leak === true);\n    alarmLevel = \"high\";\n}\nelse if (payload.hasOwnProperty('smoke')) {\n    isAlarmEvent = true;\n    alarmType = \"smoke\";\n    alarmState = (payload.smoke === true);\n    alarmLevel = \"high\";\n}\nelse if (payload.hasOwnProperty('gas')) {\n    isAlarmEvent = true;\n    alarmType = \"gas\";\n    alarmState = (payload.gas === true);\n    alarmLevel = \"high\";\n}\nelse if (payload.hasOwnProperty('carbon_monoxide')) {\n    isAlarmEvent = true;\n    alarmType = \"carbon_monoxide\";\n    alarmState = (payload.carbon_monoxide === true);\n    alarmLevel = \"high\";\n}\nelse if (payload.hasOwnProperty('tamper')) {\n    // Вскрытие корпуса датчика\n    isAlarmEvent = true;\n    alarmType = \"tamper\";\n    alarmState = (payload.tamper === true);\n    alarmLevel = \"high\";\n}\n\n// --- СРЕДНИЙ УРОВЕНЬ ВАЖНОСТИ (Warning) ---\n\nelse if (payload.hasOwnProperty('contact')) {\n    isAlarmEvent = true;\n    alarmType = \"contact\";\n    alarmState = (payload.contact === false); // Тревога, когда контакт РАЗОМКНУТ (false)\n    alarmLevel = \"medium\";\n}\nelse if (payload.hasOwnProperty('vibration')) {\n    isAlarmEvent = true;\n    alarmType = \"vibration\";\n    alarmState = (payload.vibration === true);\n    alarmLevel = \"medium\";\n}\nelse if (payload.hasOwnProperty('battery_low')) {\n    // Некоторые датчики сообщают о низком заряде как о событии\n    isAlarmEvent = true;\n    alarmType = \"battery_low\";\n    alarmState = (payload.battery_low === true);\n    alarmLevel = \"medium\";\n}\n\n// --- НИЗКИЙ УРОВЕНЬ ВАЖНОСТИ (Info) ---\n\nelse if (payload.hasOwnProperty('occupancy')) {\n    isAlarmEvent = true;\n    alarmType = \"motion\"; // Используем более понятное имя\n    alarmState = (payload.occupancy === true);\n    alarmLevel = \"medium\";\n}\nelse if (payload.hasOwnProperty('presence')) {\n    // Датчики присутствия (mmWave/радарные)\n    isAlarmEvent = true;\n    alarmType = \"presence\";\n    alarmState = (payload.presence === true);\n    alarmLevel = \"medium\";\n} \n\n// --- ФОРМИРОВАНИЕ И ОТПРАВКА СООБЩЕНИЯ ---\n\nif (isAlarmEvent) {\n    const HUB_ID = global.get(\"HUB_ID\");\n    if (!HUB_ID) {\n        node.error(\"HUB_ID not set, cannot send alarm.\");\n        return null;\n    }\n\n    // Формируем финальный payload\n    msg.payload = {\n        device_id: deviceName,\n        alarm_type: alarmType,\n        alarm_state: alarmState,\n        // Если тревога активна (true), ставим уровень (high/medium/low).\n        // Если тревога снята (false), ставим \"cleared\".\n        alarm_level: alarmState ? alarmLevel : \"cleared\",\n        timestamp: Date.now()\n    };\n\n    // Формируем топик\n    msg.topic = `iss_ai/hubs/${HUB_ID}/alarm`;\n    \n    return msg;\n}\n\n// Если входящее сообщение не содержит ни одного из отслеживаемых атрибутов,\n// оно игнорируется, и поток на этом завершается.\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 100,
        "wires": [
            [
                "e6dc03cae852d29c"
            ]
        ]
    },
    {
        "id": "e6dc03cae852d29c",
        "type": "mqtt out",
        "z": "87e4e205cb4297dd",
        "name": "",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "0c06ccdf871dbbbc",
        "x": 510,
        "y": 100,
        "wires": []
    },
    {
        "id": "89a47177d760580d",
        "type": "mqtt in",
        "z": "77646ae0e4356714",
        "name": "z2m конроль моста",
        "topic": "iss_ai/hubs/+/bridge/command",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "0c06ccdf871dbbbc",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 150,
        "y": 100,
        "wires": [
            [
                "2a8f62230978477a"
            ]
        ]
    },
    {
        "id": "2a8f62230978477a",
        "type": "function",
        "z": "77646ae0e4356714",
        "name": "фильр и путь",
        "func": "// Получаем ID нашего хаба и проверяем, что команда адресована нам\nconst myHubId = global.get(\"HUB_ID\");\nconst targetHubId = msg.topic.split('/')[2];\nif (myHubId !== targetHubId) {\n    return null;\n}\n\n// Парсим payload\nlet payload;\ntry {\n    payload = (typeof msg.payload === 'string') ? JSON.parse(msg.payload) : msg.payload;\n} catch (e) {\n    node.error(\"Invalid JSON in bridge command\", msg);\n    return null;\n}\n\n// --- Маршрутизатор Команд ---\n\n// 1. Обработка команды СОПРЯЖЕНИЯ (permit_join)\nif (payload.command === 'permit_join') {\n    msg.topic = 'zigbee2mqtt/bridge/request/permit_join';\n    // Передаем значение (true, false, число) как есть\n    msg.payload = payload.value; \n    return msg;\n}\n\n// 2. Обработка команды ПРИНУДИТЕЛЬНОГО УДАЛЕНИЯ\nif (payload.command === 'force_remove_device') {\n    const deviceIdToRemove = payload.device_id;\n    if (!deviceIdToRemove) {\n        node.error(\"Command 'force_remove_device' is missing 'device_id'.\", msg);\n        return null;\n    }\n    msg.topic = 'zigbee2mqtt/bridge/request/device/remove';\n    // Формируем payload, который ожидает Z2M\n    msg.payload = {\n        id: deviceIdToRemove,\n        force: true // Ключевой параметр!\n    };\n    return msg;\n}\n\n// Если пришла неизвестная команда, игнорируем ее\nnode.warn(\"Received unknown bridge command: \" + payload.command);\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 120,
        "wires": [
            [
                "9c3d91a3b712bbbc",
                "8f7a4dc572743653"
            ]
        ]
    },
    {
        "id": "9c3d91a3b712bbbc",
        "type": "mqtt out",
        "z": "77646ae0e4356714",
        "name": "отправка в локалку",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "93539f02eaf405c3",
        "x": 640,
        "y": 160,
        "wires": []
    },
    {
        "id": "05e3ba305edd6b95",
        "type": "mqtt in",
        "z": "77646ae0e4356714",
        "name": "",
        "topic": "zigbee2mqtt/bridge/response/#",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "93539f02eaf405c3",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 170,
        "y": 320,
        "wires": [
            [
                "66715d80fd04add1"
            ]
        ]
    },
    {
        "id": "66715d80fd04add1",
        "type": "function",
        "z": "77646ae0e4356714",
        "name": "function 5",
        "func": "// Извлекаем тип ответа из топика, например \"device/remove\"\nconst responseType = msg.topic.split('/').slice(3).join('/');\n\n// Формируем новый топик для облака\nmsg.topic = `iss_ai/hubs/${global.get(\"HUB_ID\")}/bridge/response`;\n\n// Оборачиваем payload в стандартную структуру\nmsg.payload = {\n    response_type: responseType,\n    data: msg.payload // Оригинальный ответ от Z2M\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 280,
        "wires": [
            [
                "96ba3cc24b94a57e"
            ]
        ]
    },
    {
        "id": "96ba3cc24b94a57e",
        "type": "mqtt out",
        "z": "77646ae0e4356714",
        "name": "",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "0c06ccdf871dbbbc",
        "x": 590,
        "y": 240,
        "wires": []
    },
    {
        "id": "8f7a4dc572743653",
        "type": "debug",
        "z": "77646ae0e4356714",
        "name": "debug 3",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 600,
        "y": 100,
        "wires": []
    },
    {
        "id": "1111aaaa.bbbb1111",
        "type": "exec",
        "z": "a1b2c3d4.e5f6g7",
        "command": "/opt/voice_assistant/venv/bin/python -u /opt/voice_assistant/wake_listener.py",
        "addpay": "",
        "append": "",
        "useSpawn": "true",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Wake Word Script",
        "x": 370,
        "y": 180,
        "wires": [
            [
                "aaaa1111.bbbbdddd"
            ],
            [
                "3333cccc.dddd3333"
            ],
            []
        ]
    },
    {
        "id": "4444dddd.eeee4444",
        "type": "inject",
        "z": "a1b2c3d4.e5f6g7",
        "name": "Запуск при старте",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "x": 140,
        "y": 180,
        "wires": [
            [
                "1111aaaa.bbbb1111"
            ]
        ]
    },
    {
        "id": "3333cccc.dddd3333",
        "type": "function",
        "z": "a1b2c3d4.e5f6g7",
        "name": "Store PID",
        "func": "if (typeof msg.payload === 'string' && msg.payload.startsWith(\"pid:\")) {\n    const pid = msg.payload.split(':')[1].trim();\n    flow.set(\"wake_word_pid\", pid);\n    node.log(\"Wake Word script started with PID: \" + pid);\n}\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "2222bbbb.cccc2222",
        "type": "function",
        "z": "a1b2c3d4.e5f6g7",
        "name": "Build MQTT Alarm",
        "func": "const myHubId = global.get(\"HUB_ID\") || \"unknown_hub\";\nconst detectedWord = msg.payload;\n\nmsg.topic = `iss_ai/hubs/${myHubId}/alarm`;\nmsg.payload = {\n    \"device_id\": \"voice_assistant_pi_zero\",\n    \"alarm_type\": \"wake_word_detected\",\n    \"alarm_state\": true,\n    \"alarm_level\": \"info\",\n    \"detected_word\": detectedWord,\n    \"timestamp\": Date.now()\n};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 120,
        "wires": [
            [
                "5555eeee.ffff5555",
                "6666ffff.00006666"
            ]
        ]
    },
    {
        "id": "5555eeee.ffff5555",
        "type": "mqtt out",
        "z": "a1b2c3d4.e5f6g7",
        "name": "To Local Broker",
        "topic": "",
        "qos": "1",
        "retain": "",
        "broker": "93539f02eaf405c3",
        "x": 1020,
        "y": 100,
        "wires": []
    },
    {
        "id": "6666ffff.00006666",
        "type": "mqtt out",
        "z": "a1b2c3d4.e5f6g7",
        "name": "To Cloud Broker",
        "topic": "",
        "qos": "1",
        "retain": "",
        "broker": "0c06ccdf871dbbbc",
        "x": 1020,
        "y": 160,
        "wires": []
    },
    {
        "id": "77770000.11117777",
        "type": "mqtt in",
        "z": "a1b2c3d4.e5f6g7",
        "name": "Set Wake Words Command",
        "topic": "iss_ai/hubs/+/voice_assistant/config/set",
        "qos": "2",
        "datatype": "json",
        "broker": "0c06ccdf871dbbbc",
        "nl": false,
        "rap": false,
        "rh": 0,
        "inputs": 0,
        "x": 190,
        "y": 380,
        "wires": [
            [
                "88881111.22228888"
            ]
        ]
    },
    {
        "id": "88881111.22228888",
        "type": "function",
        "z": "a1b2c3d4.e5f6g7",
        "name": "Save Words & Trigger Restart",
        "func": "const myHubId = global.get(\"HUB_ID\");\nconst targetHubId = msg.topic.split('/')[2];\nif (myHubId !== targetHubId) { return null; }\n\nif (!msg.payload || !Array.isArray(msg.payload.wake_words)) {\n    node.error(\"Invalid payload.\", msg);\n    return null;\n}\n\nconst words = msg.payload.wake_words;\nfs.writeFileSync(\"/opt/voice_assistant/wake_words.json\", JSON.stringify(words, null, 4));\nnode.log(\"Wake words updated: \" + words.join(', '));\n\n// Просто передаем сигнал дальше, чтобы запустить цепочку перезапуска\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "const fs = global.get('fs');",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            }
        ],
        "x": 510,
        "y": 380,
        "wires": [
            [
                "bbbb2222.cccc3333"
            ]
        ]
    },
    {
        "id": "99992222.33339999",
        "type": "exec",
        "z": "a1b2c3d4.e5f6g7",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Kill Old Process by PID",
        "x": 590,
        "y": 500,
        "wires": [
            [
                "00003333.44440000"
            ],
            [],
            []
        ]
    },
    {
        "id": "00003333.44440000",
        "type": "trigger",
        "z": "a1b2c3d4.e5f6g7",
        "name": "Pause & Restart",
        "op1": "",
        "op2": "",
        "op1type": "nul",
        "op2type": "nul",
        "duration": "1",
        "extend": false,
        "overrideDelay": false,
        "units": "s",
        "reset": "",
        "bytopic": "all",
        "topic": "topic",
        "outputs": 1,
        "x": 360,
        "y": 560,
        "wires": [
            [
                "1111aaaa.bbbb1111"
            ]
        ]
    },
    {
        "id": "aaaa1111.bbbbdddd",
        "type": "function",
        "z": "a1b2c3d4.e5f6g7",
        "name": "Filter & Clean Payload",
        "func": "const payload = msg.payload.trim();\n\nif (payload.startsWith(\"WAKEWORD:\")) {\n    msg.payload = payload.substring(9);\n    return msg;\n}\n\n// Весь остальной вывод (статус, ошибки, мусор) - игнорируем\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 120,
        "wires": [
            [
                "2222bbbb.cccc2222"
            ]
        ]
    },
    {
        "id": "cccc3333.dddd4444",
        "type": "inject",
        "z": "a1b2c3d4.e5f6g7",
        "name": "Перезапустить вручную",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 170,
        "y": 440,
        "wires": [
            [
                "bbbb2222.cccc3333"
            ]
        ]
    },
    {
        "id": "bbbb2222.cccc3333",
        "type": "function",
        "z": "a1b2c3d4.e5f6g7",
        "name": "Build Kill Command",
        "func": "const pid = flow.get(\"wake_word_pid\");\nif (pid) {\n    msg.payload = \"kill \" + pid;\n    return msg;\n}\n// Если PID не найден, просто останавливаем поток\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 500,
        "wires": [
            [
                "99992222.33339999"
            ]
        ]
    }
]
